<!--
====================================================================================
同期影響レポート (Sync Impact Report)
====================================================================================

バージョン変更: なし → 1.0.0

変更概要:
- 新規制定: プロジェクト憲法を新規作成
- 追加された原則:
  1. テスト駆動開発の徹底
  2. セキュリティファーストの原則
  3. パフォーマンス定量化の原則
- 追加されたセクション:
  - 制約事項
  - ガバナンス規則
  - ブランチ戦略
  - 開発方針

テンプレート更新状況:
- ✅ plan-template.md: Constitution Checkセクションと整合性確認済み
- ✅ spec-template.md: テスト要件とユーザーシナリオ整合性確認済み
- ✅ tasks-template.md: テスト駆動開発タスク構造と整合性確認済み

フォローアップ TODO:
- なし（全プレースホルダが具体値で置換済み）

制定理由:
- React+TypeScript Todoアプリケーションの品質基準を明確化
- テスト駆動開発、セキュリティ、パフォーマンスを重視した開発文化の確立
- 仕様と実装の乖離防止、再現性のある開発環境の構築

====================================================================================
-->

# Todo App プロジェクト憲法

## 核となる原則

### I. テスト駆動開発の徹底

**原則**: すべての機能開発はテストファーストで行い、仕様に対する検証を必須とする。

**規則**:
- テストコードを先に作成し、ユーザー承認を得てから実装を開始する（Red-Green-Refactorサイクル）
- すべての機能要件に対して対応するテストケースが存在しなければならない
- テストが失敗する状態を確認してから実装コードを書く
- 統合テストとユニットテストの両方を適切に組み合わせる
- テストカバレッジは単なる数値ではなく、仕様の検証度合いを示す指標とする

**理由**: テスト駆動開発により、仕様と実装の乖離を防ぎ、リファクタリング時の安全性を確保し、ドキュメントとしても機能するテストコードを維持できる。特に教育目的のプロジェクトにおいて、正しい開発プロセスを学ぶことは技術的成果物以上に重要である。

```mermaid
sequenceDiagram
    participant Dev as 開発者
    participant Test as テストコード
    participant User as ユーザー/レビュアー
    participant Impl as 実装コード
    
    Dev->>Test: 1. テスト作成
    Test->>User: 2. レビュー依頼
    User->>Test: 3. 承認
    Test->>Test: 4. 実行（Red）
    Note over Test: テスト失敗を確認
    Dev->>Impl: 5. 実装開始
    Impl->>Test: 6. テスト実行（Green）
    Note over Test: テスト成功を確認
    Dev->>Impl: 7. リファクタリング
    Impl->>Test: 8. 再テスト実行
    Note over Test: 成功を維持
```

### II. セキュリティファーストの原則

**原則**: セキュリティ要件は機能要件よりも常に優先される。

**規則**:
- 機密データ（パスワード、個人情報、トークンなど）の平文保存を禁止する
- 暗号化が必要なデータは適切なアルゴリズムで暗号化する
- パスワードは必ずハッシュ化して保存する（bcrypt、Argon2などの推奨アルゴリズムを使用）
- 外部入力は必ずバリデーションとサニタイゼーションを行う
- XSS、CSRF、SQLインジェクションなどの一般的な脆弱性対策を実装する
- セキュリティレビューを機能追加時の必須工程とする

**理由**: セキュリティは後から追加できない基盤要件である。特にWebアプリケーションでは、初期段階からセキュアな設計を組み込むことで、後の重大な脆弱性や手戻りを防ぐ。学習段階から正しいセキュリティ意識を身につけることは、プロフェッショナルな開発者として必須である。

```mermaid
flowchart LR
    A[機能要求] --> B{機密データ?}
    B -->|はい| C[暗号化/ハッシュ化]
    B -->|いいえ| D[通常処理]
    C --> E[セキュリティレビュー]
    D --> E
    E --> F{脆弱性あり?}
    F -->|はい| G[修正]
    G --> E
    F -->|なし| H[実装承認]
    
    style B fill:#ffe1e1
    style C fill:#fff4e1
    style E fill:#e1f5ff
    style F fill:#ffe1e1
    style H fill:#e1ffe1
```

### III. パフォーマンス定量化の原則

**原則**: パフォーマンス要件を定量的な閾値として定義し、受入基準に組み込む。

**規則**:
- 主要な操作（ページ読み込み、タスク追加、フィルタリングなど）の応答時間を計測可能にする
- 受け入れ基準に具体的な数値目標を設定する（例: 初期ロード < 2秒、操作応答 < 100ms）
- パフォーマンステストを自動化し、リグレッションを検知する
- メモリ使用量、レンダリング時間、バンドルサイズなどの指標を継続的に監視する
- パフォーマンス劣化はバグとして扱い、優先的に修正する
- パフォーマンス最適化の前後で定量的な効果を測定する

**理由**: 「速い」「遅い」という主観的な評価ではなく、定量的な基準を設けることで、客観的な品質管理が可能になる。ユーザー体験の質はパフォーマンスに直結するため、初期段階から計測可能な形で管理することが重要である。

```mermaid
flowchart TD
    A[機能実装] --> B[パフォーマンス計測]
    B --> C{閾値内?}
    C -->|はい| D[受入基準クリア]
    C -->|いいえ| E[最適化]
    E --> F[再計測]
    F --> G{改善確認}
    G -->|数値で確認| C
    G -->|効果なし| H[別のアプローチ]
    H --> E
    D --> I[継続監視]
    I --> J{劣化検知}
    J -->|あり| K[バグ報告]
    K --> E
    J -->|なし| I
    
    style C fill:#ffe1e1
    style D fill:#e1ffe1
    style G fill:#e1f5ff
```

## 制約事項

### データセキュリティ制約

- **CS-001**: 機密データの平文保存を完全に禁止する（暗号化またはハッシュ化が必須）
- **CS-002**: localStorageに保存するデータは暗号化を検討する（機密性に応じて）
- **CS-003**: ユーザー入力は必ずバリデーションを通過しなければならない
- **CS-004**: エラーメッセージに機密情報（スタックトレース、内部パスなど）を含めない

```mermaid
flowchart TD
    A[データ入力] --> B{機密性判定}
    B -->|高: パスワード等| C[ハッシュ化<br/>bcrypt/Argon2]
    B -->|中: 個人情報等| D[暗号化<br/>AES等]
    B -->|低: 公開情報| E[バリデーションのみ]
    C --> F[保存]
    D --> F
    E --> F
    F --> G[ストレージ]
    
    style B fill:#e1f5ff
    style C fill:#ffe1e1
    style D fill:#fff4e1
```

### 依存性管理制約

- **CS-005**: 外部依存関係はバージョン固定により再現性を確保する（package.jsonでexact version指定）
- **CS-006**: 新規依存関係の追加は必要性と代替案を検討した上で承認を得る
- **CS-007**: 脆弱性が報告された依存関係は速やかに更新する
- **CS-008**: 使用していない依存関係は定期的に削除する

```mermaid
flowchart TD
    A[新規依存関係要求] --> B{必要性評価}
    B -->|不要| C[却下]
    B -->|必要| D[代替案検討]
    D --> E{承認}
    E -->|はい| F[バージョン固定追加]
    E -->|いいえ| C
    F --> G[定期的監視]
    G --> H{脆弱性検知?}
    H -->|はい| I[速やかに更新]
    H -->|いいえ| J{使用確認}
    I --> G
    J -->|未使用| K[削除]
    J -->|使用中| G
    K --> G
    
    style B fill:#e1f5ff
    style E fill:#ffe1e1
    style H fill:#ffe1e1
```

### コード品質制約

- **CS-009**: 仕様と実装の乖離をコードレビューで検知・是正する
- **CS-010**: TypeScript strictモードを有効にし、型安全性を確保する
- **CS-011**: ESLintルール違反はビルドエラーとして扱う
- **CS-012**: デッドコード（使用されていない関数、変数）は削除する

## ガバナンス規則

### 開発プロセス

**必須作業順序**:
1. **憲法**: プロジェクト憲法の確認・更新
2. **仕様**: 機能仕様書の作成（spec.md）
3. **計画**: 実装計画の策定（plan.md）
4. **タスク**: タスク分解（tasks.md）
5. **検証**: テストコードの作成とレビュー
6. **実装**: 機能の実装
7. **レビュー**: コードレビューと承認

この順序は厳守され、逆行してはならない。各フェーズの成果物が承認されてから次に進む。

```mermaid
flowchart TD
    A[憲法確認・更新] --> B[仕様書作成]
    B --> C[実装計画策定]
    C --> D[タスク分解]
    D --> E[テストコード作成]
    E --> F{テストレビュー}
    F -->|承認| G[機能実装]
    F -->|差戻し| E
    G --> H{コードレビュー}
    H -->|承認| I[マージ]
    H -->|差戻し| G
    I --> J[完了]
    
    style A fill:#e1f5ff
    style E fill:#fff4e1
    style G fill:#e1ffe1
    style F fill:#ffe1e1
    style H fill:#ffe1e1
```

### ブランチ戦略

**ブランチフロー図**:

```mermaid
%%{init: {'theme':'base'}}%%
flowchart TB
    subgraph main["mainブランチ"]
        M1[初期状態] --> M2[仕様承認後]
        M2 --> M3[実装完了]
    end
    
    subgraph spec["仕様ブランチ: 001-feature-spec"]
        S1[spec.md作成] --> S2[plan.md作成]
        S2 --> S3[tasks.md作成]
    end
    
    subgraph impl["実装ブランチ: feature/impl-001-feature"]
        I1[テスト作成] --> I2[実装コード]
        I2 --> I3[レビュー修正]
    end
    
    M1 -.ブランチ作成.-> S1
    S3 -.マージ.-> M2
    M2 -.ブランチ作成.-> I1
    I3 -.マージ.-> M3
    
    style main fill:#e1f5ff
    style spec fill:#fff4e1
    style impl fill:#e1ffe1
```

**代替案（シンプル版）**:

```mermaid
flowchart LR
    A[main] -->|派生| B[001-feature-spec]
    B -->|spec.md| C[plan.md]
    C -->|tasks.md| D[レビュー]
    D -->|承認| E[mainへマージ]
    E -->|派生| F[feature/impl-001-feature]
    F -->|テスト| G[実装]
    G -->|レビュー| H[mainへマージ]
    
    style A fill:#e1f5ff
    style B fill:#fff4e1
    style F fill:#e1ffe1
    style E fill:#e1f5ff
    style H fill:#e1f5ff
```

#### 仕様ブランチ
```bash
# mainブランチから派生
git checkout main
git checkout -b <番号>-<短い名前>

# 例: 001-task-deletion-spec
```

**目的**: 仕様ドキュメント（spec.md, plan.md, tasks.md）の作成とレビュー

**マージ条件**: 仕様レビュー承認後にmainへマージ

#### 実装ブランチ
```bash
# 対応する仕様ブランチから派生
git checkout <番号>-<topic>
git checkout -b feature/impl-<番号>-<短い名前>

# 例: feature/impl-001-task-deletion
```

**目的**: 実装コードとテストコードの開発

**マージ条件**: 
- すべてのテストが通過
- コードレビュー承認
- 仕様との整合性確認

### レビュー要件

- **重大変更の定義**: API変更、データモデル変更、セキュリティ関連、パフォーマンス影響大
- **重大変更の承認**: 最低1名のレビュアー承認が必須
- **通常変更**: セルフレビュー可、ただしテスト通過は必須
- **レビュー観点**:
  - 憲法の原則遵守
  - 仕様との整合性
  - テストカバレッジ
  - セキュリティ考慮
  - パフォーマンス影響

```mermaid
flowchart TD
    A[プルリクエスト] --> B{変更種別}
    B -->|重大変更| C[レビュアー割当]
    B -->|通常変更| D[セルフレビュー]
    C --> E[レビュー実施]
    D --> F[テスト実行]
    E --> G{レビュー観点<br/>チェック}
    F --> H{テスト通過?}
    G -->|OK| I[承認]
    G -->|NG| J[修正要求]
    H -->|はい| I
    H -->|いいえ| J
    J --> K[修正]
    K --> B
    I --> L[マージ]
    
    style B fill:#e1f5ff
    style G fill:#ffe1e1
    style H fill:#ffe1e1
    style I fill:#e1ffe1
```

### 憲法の改定

- **改定プロセス**: 改定提案 → レビュー → 承認 → マイグレーション計画 → 実施
- **バージョニング**: セマンティックバージョニング（MAJOR.MINOR.PATCH）を使用
  - **MAJOR**: 後方互換性のない原則削除・再定義
  - **MINOR**: 新原則追加または実質的な拡張
  - **PATCH**: 明確化、文言修正、非意味的な改善
- **影響範囲の評価**: テンプレートファイル、既存仕様、実装コードへの影響を文書化
- **移行計画**: 既存コードを新原則に適合させる具体的な手順を策定

```mermaid
flowchart TD
    A[改定提案] --> B[影響範囲評価]
    B --> C{変更種別判定}
    C -->|MAJOR| D[後方互換性喪失<br/>原則削除・再定義]
    C -->|MINOR| E[新原則追加<br/>実質的拡張]
    C -->|PATCH| F[明確化<br/>文言修正]
    D --> G[レビュー]
    E --> G
    F --> G
    G --> H{承認}
    H -->|はい| I[マイグレーション計画]
    H -->|いいえ| J[差戻し]
    I --> K[テンプレート更新]
    K --> L[既存仕様更新]
    L --> M[実装コード更新]
    M --> N[バージョン更新]
    N --> O[公開]
    J --> A
    
    style C fill:#e1f5ff
    style D fill:#ffe1e1
    style E fill:#fff4e1
    style F fill:#e1ffe1
    style H fill:#ffe1e1
```

### コンプライアンス検証

- **すべてのPR**: 憲法遵守を確認
- **複雑性の正当化**: 憲法違反が必要な場合、その理由と代替案を文書化
- **定期レビュー**: 月次で憲法と実態の乖離をチェック

## 開発方針

### フルスタック同時起動

- フロントエンドとバックエンドを同時に起動するスクリプトを提供する
- `start.ps1` によるワンコマンド起動を実現
- 開発サーバーの自動起動、ヘルスチェック、ブラウザオープンを自動化

```mermaid
sequenceDiagram
    participant User as 開発者
    participant Script as start.ps1
    participant NPM as npm
    participant Server as Dev Server
    participant Browser as ブラウザ
    
    User->>Script: .\start.ps1 実行
    Script->>NPM: 依存関係確認
    alt 未インストール
        NPM->>NPM: npm install
    end
    Script->>Server: バックグラウンド起動
    Server->>Server: ポート1234でリッスン
    Script->>Server: ヘルスチェック（最大30秒）
    Server-->>Script: 起動完了
    Script->>Browser: http://localhost:1234 を開く
    Script->>User: 5秒後に自動終了
    Note over Server: バックグラウンドで継続実行
```

### 品質保証

- **動作確認の徹底**: 正常に動作するまで検証を繰り返す
- **エラー修正の完了**: エラーが解消されるまで次の作業に進まない
- **継続的な改善**: トークン制限まで生成ドキュメントを繰り返しブラッシュアップする
- **簡略化の禁止**: トークン制限を理由に品質を低下させない

```mermaid
flowchart TD
    A[機能実装] --> B[動作確認]
    B --> C{正常動作?}
    C -->|いいえ| D[エラー検出]
    C -->|はい| E[品質チェック]
    D --> F[原因分析]
    F --> G[修正]
    G --> B
    E --> H{品質基準?}
    H -->|未達| I[改善]
    I --> B
    H -->|達成| J{トークン余裕?}
    J -->|あり| K[ブラッシュアップ]
    K --> L{さらに改善?}
    L -->|はい| B
    L -->|いいえ| M[完了]
    J -->|なし| M
    
    style C fill:#ffe1e1
    style H fill:#e1f5ff
    style M fill:#e1ffe1
```

### ドキュメンテーション

- **Mermaid図の活用**: フローチャート、シーケンス図などを適切に挿入
- **視覚的な説明**: 複雑なロジックは図解で補完
- **コメントの充実**: コードの意図を明確に記述
- **仕様書の保守**: 実装変更時は必ず仕様書も更新

### ファイルエンコーディング

- **UTF-8必須**: すべてのファイルはUTF-8エンコーディングで保存
- **文字化け防止**: 日本語ドキュメントは特に注意してエンコーディングを確認

---

**バージョン**: 1.0.0 | **制定日**: 2025-11-13 | **最終改定日**: 2025-11-13
